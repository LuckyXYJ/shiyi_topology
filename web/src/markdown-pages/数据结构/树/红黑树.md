# 红黑树

> 红黑树相对于AVL树来说，插入、删除等操作的时候，牺牲了平衡性来减少左旋或者右旋的次数，因此整体来说性能要优于AVL树。
>
> 但是，只比较查找方面的效率的话，平衡树比红黑树快。
>
> AVL树和红黑树插入节点的时候均需要`O(1)`次旋转操作，而当删除一个节点时，AVL树最坏需要`O(logN)`次旋转而红黑树仍然只需要`O(1)`次旋转。
>
> 动画: https://www.cs.usfca.edu/~galles/visualization/RedBlack.html

## 特点

1. 具有二叉查找树的特点。

2. 根节点是黑色的；

3. 所有叶子都是黑色（叶子是NIL节点）

4. 每个红色节点必须有两个黑色的子节点。

5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

   

   下图展示了一个典型的红黑树:

   ![红黑树-基本](http://java-engineer.ztianzeng.com/uPic/%E7%BA%A2%E9%BB%91%E6%A0%91-%E5%9F%BA%E6%9C%AC.png)

## 插入操作

**红黑树**的插入操作是和**二叉查找树**是一样的，区别就在于元素插入之后，会导致树的不平衡，进而不符合**红黑树**的特性，我们需要通过重新对树进行旋转和着色，让其恢复**红黑树**的特性。

#### 插入Case-1

如果插入的节点的父节点，是黑色是不需要进行任何的改变。

![插入节点66](http://java-engineer.ztianzeng.com/uPic/%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B966.png)

#### 插入Case-2

如果插入的节点的父节点是红色，则需要进行调整。

将父节点和叔叔节点与祖父节点的颜色互换，这样就符合了RBTRee的定义。

即维持了高度的平衡，修复后颜色也符合RBTree定义的第三条和第四条。如果父节点的父节点不是黑色的话，则继续做修复操作。

**叔叔节点也为红色的情况**

![插入节点51](http://java-engineer.ztianzeng.com/uPic/%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B951.png)

#### 插入Case-3

**叔叔节点为空，且祖父节点、父节点和新节点处于一条斜线上**

这个时候就没有办法通过变色，使其恢复红黑树的特性，需要进行旋转

下图展示了LL形状的旋转，RR形旋转也是同理。

![红黑树-Case3](http://java-engineer.ztianzeng.com/uPic/%E7%BA%A2%E9%BB%91%E6%A0%91-Case3.png)

#### 插入Case-4

叔叔节点为空，且祖父节点、父节点和新节点**不处于一条斜线上**

LR形状和RL形状都是属于不在一条直线上。

下图展示了，LR形状的旋转:

![红黑树-Case4](http://java-engineer.ztianzeng.com/uPic/%E7%BA%A2%E9%BB%91%E6%A0%91-Case4.png)





## 删除操作

删除操作的总体思想是从兄弟节点借调黑色节点使树保持局部的平衡，如果局部的平衡达到了，就看整体的树是否是平衡的，如果不平衡就接着向上追溯调整。

#### 删除Case-1

删除的是红色节点，直接删除



![红黑树-删除-Case1](http://java-engineer.ztianzeng.com/uPic/%E7%BA%A2%E9%BB%91%E6%A0%91-%E5%88%A0%E9%99%A4-Case1.png)

#### 删除Case-2

带删除的节点的兄弟节点是红色的。

围绕待删除的节点的父节点，进行旋转，然后在通过插入的规则，进行染色，让其重新平衡



![红黑树-删除-Case2](http://java-engineer.ztianzeng.com/uPic/%E7%BA%A2%E9%BB%91%E6%A0%91-%E5%88%A0%E9%99%A4-Case2.png)

#### 插入Case-3

待删除的节点的兄弟节点是黑色的节点，且兄弟节点的子节点都是黑色的。

右节点顶上，兄弟节点变色，然后根据整体情况再进行变色。

![红黑树-删除-Case3](http://java-engineer.ztianzeng.com/uPic/%E7%BA%A2%E9%BB%91%E6%A0%91-%E5%88%A0%E9%99%A4-Case3.png)

#### 删除Case-4

兄弟节点是黑色的节点，且兄弟节点的左子节点是红色的，右节点是黑色的(兄弟节点在右边)，如果兄弟节点在左边的话，就是兄弟节点的右子节点是红色的，左节点是黑色的。

#### 删除Case-4

节点的兄弟节点是黑色的节点，且右子节点是是红色的(兄弟节点在右边)，如果兄弟节点在左边，则就是对应的就是左节点是红色的。

### 删除操作的总结

红黑树的删除操作是最复杂的操作，复杂的地方就在于当删除了黑色节点的时候，如何从兄弟节点去借调节点，以保证树的颜色符合定义。由于红色的兄弟节点是没法借调出黑节点的，这样只能通过选择操作让他上升到父节点，而由于它是红节点，所以它的子节点就是黑的，可以借调。

对于兄弟节点是黑色节点的可以分成3种情况来处理，当所以的兄弟节点的子节点都是黑色节点时，可以直接将兄弟节点变红，这样局部的红黑树颜色是符合定义的。但是整颗树不一定是符合红黑树定义的，需要往上追溯继续调整。

对于兄弟节点的子节点为左红右黑或者 (全部为红，右红左黑)这两种情况，可以先将前面的情况通过选择转换为后一种情况，在后一种情况下，因为兄弟节点为黑，兄弟节点的右节点为红，可以借调出两个节点出来做黑节点，这样就可以保证删除了黑节点，整棵树还是符合红黑树的定义的，因为黑色节点的个数没有改变。

红黑树的删除操作是遇到删除的节点为红色，或者追溯调整到了root节点，这时删除的修复操作完毕。

## 总结

作为平衡二叉查找树里面众多的实现之一，红黑树无疑是最简洁、实现最为简单的。

红黑树通过引入颜色的概念，通过颜色这个约束条件的使用来保持树的高度平衡。作为平衡二叉查找树，旋转是一个必不可少的操作。通过旋转可以降低树的高度，在红黑树里面还可以转换颜色。

红黑树里面的插入和删除的操作比较难理解，这时要注意记住一点：操作之前红黑树是平衡的，颜色是符合定义的。

在操作的时候就需要向兄弟节点、父节点、侄子节点借调和互换颜色，要达到这个目的，就需要不断的进行旋转。所以红黑树的插入删除操作需要不停的旋转，一旦借调了别的节点，删除和插入的节点就会达到局部的平衡（局部符合红黑树的定义），但是被借调的节点就不会平衡了，这时就需要以被借调的节点为起点继续进行调整，直到整棵树都是平衡的。在整个修复的过程中，插入具体的分为3种情况，删除分为4种情况。

整个红黑树的查找，插入和删除都是O(logN)的，原因就是整个红黑树的高度是logN，查找从根到叶，走过的路径是树的高度，删除和插入操作是从叶到根的，所以经过的路径都是logN。

参考:

https://tech.meituan.com/2016/12/02/redblack-tree.html

https://zhuanlan.zhihu.com/p/97523789