[{"tree":"[{\"type\":\"heading\",\"index\":0,\"level\":1,\"text\":\"Java并发工具包\",\"listNo\":\"1\",\"parentNo\":\"\",\"href\":\"/并发/README#Java并发工具包\",\"child\":[{\"type\":\"heading\",\"index\":1,\"level\":2,\"text\":\"并发基础\",\"listNo\":\"1.1\",\"parentNo\":\"1\",\"href\":\"/并发/README#并发基础\",\"child\":[{\"type\":\"heading\",\"index\":2,\"level\":3,\"text\":\"线程基础\",\"listNo\":\"1.1.1\",\"parentNo\":\"1.1\",\"href\":\"/并发/README#线程基础\",\"child\":[{\"index\":3,\"type\":\"list_item\",\"level\":4,\"text\":\"进程和线程的区别\",\"listNo\":\"1.1.1.1\",\"parentNo\":\"1.1.1\",\"href\":\"/并发/进程与线程\",\"child\":[{\"type\":\"heading\",\"index\":1,\"level\":2,\"text\":\"概述\",\"listNo\":\"1.1\",\"parentNo\":\"1\",\"href\":\"/并发/进程与线程#概述\",\"child\":[]}]},{\"index\":4,\"type\":\"list_item\",\"level\":4,\"text\":\"线程的实现方法\",\"listNo\":\"1.1.1.2\",\"parentNo\":\"1.1.1\",\"href\":\"/并发/Thread的实现方式\",\"child\":[{\"type\":\"heading\",\"index\":1,\"level\":2,\"text\":\"实现Runable接口\",\"listNo\":\"1.1\",\"parentNo\":\"1\",\"href\":\"/并发/Thread的实现方式#实现Runable接口\",\"child\":[]},{\"type\":\"heading\",\"index\":5,\"level\":2,\"text\":\"直接继承Thread\",\"listNo\":\"1.2\",\"parentNo\":\"1\",\"href\":\"/并发/Thread的实现方式#直接继承Thread\",\"child\":[]},{\"type\":\"heading\",\"index\":6,\"level\":2,\"text\":\"用线程池创建线程\",\"listNo\":\"1.3\",\"parentNo\":\"1\",\"href\":\"/并发/Thread的实现方式#用线程池创建线程\",\"child\":[]},{\"type\":\"heading\",\"index\":7,\"level\":2,\"text\":\"使用Callable方式创建\",\"listNo\":\"1.4\",\"parentNo\":\"1\",\"href\":\"/并发/Thread的实现方式#使用Callable方式创建\",\"child\":[]},{\"type\":\"heading\",\"index\":8,\"level\":2,\"text\":\"使用Timer\",\"listNo\":\"1.5\",\"parentNo\":\"1\",\"href\":\"/并发/Thread的实现方式#使用Timer\",\"child\":[]},{\"type\":\"heading\",\"index\":9,\"level\":2,\"text\":\"本质?\",\"listNo\":\"1.6\",\"parentNo\":\"1\",\"href\":\"/并发/Thread的实现方式#本质?\",\"child\":[]}]},{\"index\":5,\"type\":\"list_item\",\"level\":4,\"text\":\"如何正确地停止线程\",\"listNo\":\"1.1.1.3\",\"parentNo\":\"1.1.1\",\"href\":\"/并发/正确停止线程的方式\",\"child\":[{\"type\":\"heading\",\"index\":4,\"level\":2,\"text\":\"废弃的停止方式\",\"listNo\":\"1.4\",\"parentNo\":\"1\",\"href\":\"/并发/正确停止线程的方式#废弃的停止方式\",\"child\":[{\"type\":\"heading\",\"index\":5,\"level\":3,\"text\":\"Thread.stop和suspend被废弃的原因\",\"listNo\":\"1.4.1\",\"parentNo\":\"1.4\",\"href\":\"/并发/正确停止线程的方式#Thread.stop和suspend被废弃的原因\",\"child\":[]},{\"type\":\"heading\",\"index\":6,\"level\":3,\"text\":\"volatile标记停止位的错误\",\"listNo\":\"1.4.2\",\"parentNo\":\"1.4\",\"href\":\"/并发/正确停止线程的方式#volatile标记停止位的错误\",\"child\":[]}]},{\"type\":\"heading\",\"index\":7,\"level\":2,\"text\":\"正确的停止方式\",\"listNo\":\"1.5\",\"parentNo\":\"1\",\"href\":\"/并发/正确停止线程的方式#正确的停止方式\",\"child\":[{\"type\":\"heading\",\"index\":8,\"level\":3,\"text\":\"通过interrupt方式停止\",\"listNo\":\"1.5.1\",\"parentNo\":\"1.5\",\"href\":\"/并发/正确停止线程的方式#通过interrupt方式停止\",\"child\":[]}]},{\"type\":\"heading\",\"index\":9,\"level\":2,\"text\":\"所以Java中如何正确的停止线程\",\"listNo\":\"1.6\",\"parentNo\":\"1\",\"href\":\"/并发/正确停止线程的方式#所以Java中如何正确的停止线程\",\"child\":[{\"type\":\"heading\",\"index\":10,\"level\":3,\"text\":\"答题思路\",\"listNo\":\"1.6.1\",\"parentNo\":\"1.6\",\"href\":\"/并发/正确停止线程的方式#答题思路\",\"child\":[]}]}]},{\"index\":6,\"type\":\"list_item\",\"level\":4,\"text\":\"线程有哪些状态\",\"listNo\":\"1.1.1.4\",\"parentNo\":\"1.1.1\",\"href\":\"/并发/Thread的状态\",\"child\":[{\"type\":\"heading\",\"index\":1,\"level\":2,\"text\":\"New\",\"listNo\":\"1.1\",\"parentNo\":\"1\",\"href\":\"/并发/Thread的状态#New\",\"child\":[]},{\"type\":\"heading\",\"index\":2,\"level\":2,\"text\":\"Runable\",\"listNo\":\"1.2\",\"parentNo\":\"1\",\"href\":\"/并发/Thread的状态#Runable\",\"child\":[]},{\"type\":\"heading\",\"index\":3,\"level\":2,\"text\":\"阻塞态\",\"listNo\":\"1.3\",\"parentNo\":\"1\",\"href\":\"/并发/Thread的状态#阻塞态\",\"child\":[{\"type\":\"heading\",\"index\":4,\"level\":3,\"text\":\"Block\",\"listNo\":\"1.3.1\",\"parentNo\":\"1.3\",\"href\":\"/并发/Thread的状态#Block\",\"child\":[]},{\"type\":\"heading\",\"index\":5,\"level\":3,\"text\":\"Timed Watting\",\"listNo\":\"1.3.2\",\"parentNo\":\"1.3\",\"href\":\"/并发/Thread的状态#Timed Watting\",\"child\":[]}]},{\"type\":\"heading\",\"index\":9,\"level\":2,\"text\":\"Watting\",\"listNo\":\"1.4\",\"parentNo\":\"1\",\"href\":\"/并发/Thread的状态#Watting\",\"child\":[]}]},{\"index\":7,\"type\":\"list_item\",\"level\":4,\"text\":\"wait、notify/notifyAll、sleep方法\",\"listNo\":\"1.1.1.5\",\"parentNo\":\"1.1.1\",\"href\":\"/并发/waitnotifynotifyAll\",\"child\":[{\"type\":\"heading\",\"index\":1,\"level\":2,\"text\":\"为什么wait必须在synchronized保护的代码中使用\",\"listNo\":\"1.1\",\"parentNo\":\"1\",\"href\":\"/并发/waitnotifynotifyAll#为什么wait必须在synchronized保护的代码中使用\",\"child\":[]},{\"type\":\"heading\",\"index\":7,\"level\":2,\"text\":\"为什么 wait/notify/notifyAll 被定义在 Object 类中，而 sleep 定义在 Thread 类中？\",\"listNo\":\"1.2\",\"parentNo\":\"1\",\"href\":\"/并发/waitnotifynotifyAll#为什么 wait/notify/notifyAll 被定义在 Object 类中，而 sleep 定义在 Thread 类中？\",\"child\":[]},{\"type\":\"heading\",\"index\":10,\"level\":2,\"text\":\"wait/notify 和 sleep 方法的异同？\",\"listNo\":\"1.3\",\"parentNo\":\"1\",\"href\":\"/并发/waitnotifynotifyAll#wait/notify 和 sleep 方法的异同？\",\"child\":[]}]},{\"index\":8,\"type\":\"list_item\",\"level\":4,\"text\":\"生产者消费者模型\",\"listNo\":\"1.1.1.6\",\"parentNo\":\"1.1.1\",\"href\":\"/并发/生产者消费者模型\",\"child\":[{\"type\":\"heading\",\"index\":1,\"level\":2,\"text\":\"生产者消费者模式\",\"listNo\":\"1.1\",\"parentNo\":\"1\",\"href\":\"/并发/生产者消费者模型#生产者消费者模式\",\"child\":[]},{\"type\":\"heading\",\"index\":4,\"level\":2,\"text\":\"使用 BlockingQueue 实现生产者消费者模式\",\"listNo\":\"1.2\",\"parentNo\":\"1\",\"href\":\"/并发/生产者消费者模型#使用 BlockingQueue 实现生产者消费者模式\",\"child\":[]},{\"type\":\"heading\",\"index\":5,\"level\":2,\"text\":\"使用 Condition 实现生产者消费者模式\",\"listNo\":\"1.3\",\"parentNo\":\"1\",\"href\":\"/并发/生产者消费者模型#使用 Condition 实现生产者消费者模式\",\"child\":[]},{\"type\":\"heading\",\"index\":6,\"level\":2,\"text\":\"使用 wait/notify 实现生产者消费者模式\",\"listNo\":\"1.4\",\"parentNo\":\"1\",\"href\":\"/并发/生产者消费者模型#使用 wait/notify 实现生产者消费者模式\",\"child\":[]}]}]},{\"type\":\"heading\",\"index\":9,\"level\":3,\"text\":\"线程安全\",\"listNo\":\"1.1.2\",\"parentNo\":\"1.1\",\"href\":\"/并发/README#线程安全\",\"child\":[{\"index\":10,\"type\":\"list_item\",\"level\":4,\"text\":\"3类线程安全问题\",\"listNo\":\"1.1.2.1\",\"parentNo\":\"1.1.2\",\"href\":\"/并发/线程安全\",\"child\":[{\"type\":\"heading\",\"index\":1,\"level\":2,\"text\":\"什么是线程安全问题\",\"listNo\":\"1.1\",\"parentNo\":\"1\",\"href\":\"/并发/线程安全#什么是线程安全问题\",\"child\":[]},{\"type\":\"heading\",\"index\":2,\"level\":2,\"text\":\"为何会出现线程安全问题\",\"listNo\":\"1.2\",\"parentNo\":\"1\",\"href\":\"/并发/线程安全#为何会出现线程安全问题\",\"child\":[{\"type\":\"heading\",\"index\":6,\"level\":3,\"text\":\"可见性: CPU缓存引起\",\"listNo\":\"1.2.4\",\"parentNo\":\"1.2\",\"href\":\"/并发/线程安全#可见性: CPU缓存引起\",\"child\":[]},{\"type\":\"heading\",\"index\":8,\"level\":3,\"text\":\"原子性: 分时复用引起\",\"listNo\":\"1.2.5\",\"parentNo\":\"1.2\",\"href\":\"/并发/线程安全#原子性: 分时复用引起\",\"child\":[]},{\"type\":\"heading\",\"index\":9,\"level\":3,\"text\":\"有序性: 重排序引起\",\"listNo\":\"1.2.6\",\"parentNo\":\"1.2\",\"href\":\"/并发/线程安全#有序性: 重排序引起\",\"child\":[]}]},{\"type\":\"heading\",\"index\":13,\"level\":2,\"text\":\"一共有哪三类线程安全问题\",\"listNo\":\"1.3\",\"parentNo\":\"1\",\"href\":\"/并发/线程安全#一共有哪三类线程安全问题\",\"child\":[{\"type\":\"heading\",\"index\":14,\"level\":3,\"text\":\"运行结果错误\",\"listNo\":\"1.3.1\",\"parentNo\":\"1.3\",\"href\":\"/并发/线程安全#运行结果错误\",\"child\":[]},{\"type\":\"heading\",\"index\":23,\"level\":3,\"text\":\"发布和初始化导致线程安全问题\",\"listNo\":\"1.3.2\",\"parentNo\":\"1.3\",\"href\":\"/并发/线程安全#发布和初始化导致线程安全问题\",\"child\":[]},{\"type\":\"heading\",\"index\":24,\"level\":3,\"text\":\"活跃性问题\",\"listNo\":\"1.3.3\",\"parentNo\":\"1.3\",\"href\":\"/并发/线程安全#活跃性问题\",\"child\":[{\"type\":\"heading\",\"index\":25,\"level\":4,\"text\":\"死锁\",\"listNo\":\"1.3.3.1\",\"parentNo\":\"1.3.3\",\"href\":\"/并发/线程安全#死锁\",\"child\":[]},{\"type\":\"heading\",\"index\":26,\"level\":4,\"text\":\"活锁\",\"listNo\":\"1.3.3.2\",\"parentNo\":\"1.3.3\",\"href\":\"/并发/线程安全#活锁\",\"child\":[]},{\"type\":\"heading\",\"index\":27,\"level\":4,\"text\":\"饥饿\",\"listNo\":\"1.3.3.3\",\"parentNo\":\"1.3.3\",\"href\":\"/并发/线程安全#饥饿\",\"child\":[]}]}]}]},{\"index\":11,\"type\":\"list_item\",\"level\":4,\"text\":\"哪些情景下需要注意线程安全问题\",\"listNo\":\"1.1.2.2\",\"parentNo\":\"1.1.2\",\"href\":\"/并发/需要注意线程安全问题的情况\",\"child\":[{\"type\":\"heading\",\"index\":1,\"level\":2,\"text\":\"访问共享变量或资源\",\"listNo\":\"1.1\",\"parentNo\":\"1\",\"href\":\"/并发/需要注意线程安全问题的情况#访问共享变量或资源\",\"child\":[]},{\"type\":\"heading\",\"index\":2,\"level\":2,\"text\":\"依赖时序的操作\",\"listNo\":\"1.2\",\"parentNo\":\"1\",\"href\":\"/并发/需要注意线程安全问题的情况#依赖时序的操作\",\"child\":[]},{\"type\":\"heading\",\"index\":3,\"level\":2,\"text\":\"对方没有声明自己是线程安全的\",\"listNo\":\"1.3\",\"parentNo\":\"1\",\"href\":\"/并发/需要注意线程安全问题的情况#对方没有声明自己是线程安全的\",\"child\":[]}]}]}]},{\"type\":\"heading\",\"index\":12,\"level\":2,\"text\":\"并发工具\",\"listNo\":\"1.2\",\"parentNo\":\"1\",\"href\":\"/并发/README#并发工具\",\"child\":[{\"type\":\"heading\",\"index\":13,\"level\":3,\"text\":\"线程池\",\"listNo\":\"1.2.1\",\"parentNo\":\"1.2\",\"href\":\"/并发/README#线程池\",\"child\":[{\"index\":14,\"type\":\"list_item\",\"level\":4,\"text\":\"多线程的性能问题\",\"listNo\":\"1.2.1.1\",\"parentNo\":\"1.2.1\",\"href\":\"/并发/为什么多线程会带来性能问题\",\"child\":[{\"type\":\"heading\",\"index\":1,\"level\":2,\"text\":\"线程调度开销\",\"listNo\":\"1.1\",\"parentNo\":\"1\",\"href\":\"/并发/为什么多线程会带来性能问题#线程调度开销\",\"child\":[{\"type\":\"heading\",\"index\":2,\"level\":3,\"text\":\"上下文切换\",\"listNo\":\"1.1.1\",\"parentNo\":\"1.1\",\"href\":\"/并发/为什么多线程会带来性能问题#上下文切换\",\"child\":[]},{\"type\":\"heading\",\"index\":3,\"level\":3,\"text\":\"缓存失效\",\"listNo\":\"1.1.2\",\"parentNo\":\"1.1\",\"href\":\"/并发/为什么多线程会带来性能问题#缓存失效\",\"child\":[]}]},{\"type\":\"heading\",\"index\":4,\"level\":2,\"text\":\"协作开销\",\"listNo\":\"1.2\",\"parentNo\":\"1\",\"href\":\"/并发/为什么多线程会带来性能问题#协作开销\",\"child\":[]}]},{\"index\":15,\"type\":\"list_item\",\"level\":4,\"text\":\"线程池的优势\",\"listNo\":\"1.2.1.2\",\"parentNo\":\"1.2.1\",\"href\":\"/并发/线程池的优势\",\"child\":[{\"type\":\"heading\",\"index\":1,\"level\":2,\"text\":\"如何提升运行效率\",\"listNo\":\"1.1\",\"parentNo\":\"1\",\"href\":\"/并发/线程池的优势#如何提升运行效率\",\"child\":[]},{\"type\":\"heading\",\"index\":4,\"level\":2,\"text\":\"使用线程池的好处\",\"listNo\":\"1.2\",\"parentNo\":\"1\",\"href\":\"/并发/线程池的优势#使用线程池的好处\",\"child\":[]},{\"type\":\"heading\",\"index\":8,\"level\":2,\"text\":\"线程池的思想\",\"listNo\":\"1.3\",\"parentNo\":\"1\",\"href\":\"/并发/线程池的优势#线程池的思想\",\"child\":[]}]},{\"index\":16,\"type\":\"list_item\",\"level\":4,\"text\":\"如何创建线程池\",\"listNo\":\"1.2.1.3\",\"parentNo\":\"1.2.1\",\"href\":\"/并发/创建线程池的参数\",\"child\":[{\"type\":\"heading\",\"index\":1,\"level\":2,\"text\":\"创建线程池的参数\",\"listNo\":\"1.1\",\"parentNo\":\"1\",\"href\":\"/并发/创建线程池的参数#创建线程池的参数\",\"child\":[]},{\"type\":\"heading\",\"index\":2,\"level\":2,\"text\":\"线程池创建线程的时机\",\"listNo\":\"1.2\",\"parentNo\":\"1\",\"href\":\"/并发/创建线程池的参数#线程池创建线程的时机\",\"child\":[]},{\"type\":\"heading\",\"index\":3,\"level\":2,\"text\":\"线程工厂ThreadFactory\",\"listNo\":\"1.3\",\"parentNo\":\"1\",\"href\":\"/并发/创建线程池的参数#线程工厂ThreadFactory\",\"child\":[]},{\"type\":\"heading\",\"index\":4,\"level\":2,\"text\":\"工作队列WorkQueue\",\"listNo\":\"1.4\",\"parentNo\":\"1\",\"href\":\"/并发/创建线程池的参数#工作队列WorkQueue\",\"child\":[]},{\"type\":\"heading\",\"index\":6,\"level\":2,\"text\":\"拒绝策略Handler\",\"listNo\":\"1.5\",\"parentNo\":\"1\",\"href\":\"/并发/创建线程池的参数#拒绝策略Handler\",\"child\":[{\"type\":\"heading\",\"index\":7,\"level\":3,\"text\":\"DiscardPolicy\",\"listNo\":\"1.5.1\",\"parentNo\":\"1.5\",\"href\":\"/并发/创建线程池的参数#DiscardPolicy\",\"child\":[]},{\"type\":\"heading\",\"index\":8,\"level\":3,\"text\":\"DiscardOldestPolicy\",\"listNo\":\"1.5.2\",\"parentNo\":\"1.5\",\"href\":\"/并发/创建线程池的参数#DiscardOldestPolicy\",\"child\":[]},{\"type\":\"heading\",\"index\":9,\"level\":3,\"text\":\"CallerRunsPolicy\",\"listNo\":\"1.5.3\",\"parentNo\":\"1.5\",\"href\":\"/并发/创建线程池的参数#CallerRunsPolicy\",\"child\":[]},{\"type\":\"heading\",\"index\":10,\"level\":3,\"text\":\"AbortPolicy\",\"listNo\":\"1.5.4\",\"parentNo\":\"1.5\",\"href\":\"/并发/创建线程池的参数#AbortPolicy\",\"child\":[]}]}]},{\"index\":17,\"type\":\"list_item\",\"level\":4,\"text\":\"线程池复用原理\",\"listNo\":\"1.2.1.4\",\"parentNo\":\"1.2.1\",\"href\":\"/并发/线程池线程复用原理\",\"child\":[{\"type\":\"heading\",\"index\":5,\"level\":2,\"text\":\"实现方式\",\"listNo\":\"1.5\",\"parentNo\":\"1\",\"href\":\"/并发/线程池线程复用原理#实现方式\",\"child\":[]},{\"type\":\"heading\",\"index\":6,\"level\":2,\"text\":\"总结\",\"listNo\":\"1.6\",\"parentNo\":\"1\",\"href\":\"/并发/线程池线程复用原理#总结\",\"child\":[]}]},{\"index\":18,\"type\":\"list_item\",\"level\":4,\"text\":\"特殊的线程池Forkjoin\",\"listNo\":\"1.2.1.5\",\"parentNo\":\"1.2.1\",\"href\":\"/并发/ForkJoin框架\",\"child\":[{\"type\":\"heading\",\"index\":1,\"level\":2,\"text\":\"案例?\",\"listNo\":\"1.1\",\"parentNo\":\"1\",\"href\":\"/并发/ForkJoin框架#案例?\",\"child\":[]},{\"type\":\"heading\",\"index\":2,\"level\":2,\"text\":\"原理\",\"listNo\":\"1.2\",\"parentNo\":\"1\",\"href\":\"/并发/ForkJoin框架#原理\",\"child\":[{\"type\":\"heading\",\"index\":15,\"level\":3,\"text\":\"执行流程\",\"listNo\":\"1.2.5\",\"parentNo\":\"1.2\",\"href\":\"/并发/ForkJoin框架#执行流程\",\"child\":[]},{\"type\":\"heading\",\"index\":16,\"level\":3,\"text\":\"步骤分解\",\"listNo\":\"1.2.6\",\"parentNo\":\"1.2\",\"href\":\"/并发/ForkJoin框架#步骤分解\",\"child\":[]},{\"type\":\"heading\",\"index\":21,\"level\":3,\"text\":\"外部任务提交\",\"listNo\":\"1.2.7\",\"parentNo\":\"1.2\",\"href\":\"/并发/ForkJoin框架#外部任务提交\",\"child\":[]},{\"type\":\"heading\",\"index\":22,\"level\":3,\"text\":\"子任务提交\",\"listNo\":\"1.2.8\",\"parentNo\":\"1.2\",\"href\":\"/并发/ForkJoin框架#子任务提交\",\"child\":[]},{\"type\":\"heading\",\"index\":23,\"level\":3,\"text\":\"执行任务\",\"listNo\":\"1.2.9\",\"parentNo\":\"1.2\",\"href\":\"/并发/ForkJoin框架#执行任务\",\"child\":[]},{\"type\":\"heading\",\"index\":24,\"level\":3,\"text\":\"获取任务执行结果\",\"listNo\":\"1.2.10\",\"parentNo\":\"1.2\",\"href\":\"/并发/ForkJoin框架#获取任务执行结果\",\"child\":[]}]}]}]},{\"type\":\"heading\",\"index\":19,\"level\":3,\"text\":\"各种锁\",\"listNo\":\"1.2.2\",\"parentNo\":\"1.2\",\"href\":\"/并发/README#各种锁\",\"child\":[{\"index\":20,\"type\":\"list_item\",\"level\":4,\"text\":\"锁的种类和特点\",\"listNo\":\"1.2.2.1\",\"parentNo\":\"1.2.2\",\"href\":\"/并发/锁的种类和特点\",\"child\":[{\"type\":\"heading\",\"index\":8,\"level\":2,\"text\":\"偏向锁/轻量级锁/重量级锁\",\"listNo\":\"1.8\",\"parentNo\":\"1\",\"href\":\"/并发/锁的种类和特点#偏向锁/轻量级锁/重量级锁\",\"child\":[]},{\"type\":\"heading\",\"index\":12,\"level\":2,\"text\":\"可重入锁/不可重入锁\",\"listNo\":\"1.9\",\"parentNo\":\"1\",\"href\":\"/并发/锁的种类和特点#可重入锁/不可重入锁\",\"child\":[]},{\"type\":\"heading\",\"index\":13,\"level\":2,\"text\":\"共享锁/独占锁\",\"listNo\":\"1.10\",\"parentNo\":\"1\",\"href\":\"/并发/共享锁独占锁\",\"child\":[{\"type\":\"heading\",\"index\":1,\"level\":2,\"text\":\"读写锁的规则\",\"listNo\":\"1.1\",\"parentNo\":\"1\",\"href\":\"/并发/共享锁独占锁#读写锁的规则\",\"child\":[]},{\"type\":\"heading\",\"index\":10,\"level\":2,\"text\":\"使用方式\",\"listNo\":\"1.4\",\"parentNo\":\"1\",\"href\":\"/并发/共享锁独占锁#使用方式\",\"child\":[]},{\"type\":\"heading\",\"index\":11,\"level\":2,\"text\":\"加锁原理分析\",\"listNo\":\"1.5\",\"parentNo\":\"1\",\"href\":\"/并发/共享锁独占锁#加锁原理分析\",\"child\":[]},{\"type\":\"heading\",\"index\":12,\"level\":2,\"text\":\"插队逻辑\",\"listNo\":\"1.6\",\"parentNo\":\"1\",\"href\":\"/并发/共享锁独占锁#插队逻辑\",\"child\":[{\"type\":\"heading\",\"index\":13,\"level\":3,\"text\":\"第一种策略：允许插队\",\"listNo\":\"1.6.1\",\"parentNo\":\"1.6\",\"href\":\"/并发/共享锁独占锁#第一种策略：允许插队\",\"child\":[]},{\"type\":\"heading\",\"index\":14,\"level\":3,\"text\":\"第二种策略：不允许插队\",\"listNo\":\"1.6.2\",\"parentNo\":\"1.6\",\"href\":\"/并发/共享锁独占锁#第二种策略：不允许插队\",\"child\":[]}]},{\"type\":\"heading\",\"index\":15,\"level\":2,\"text\":\"锁的升降级\",\"listNo\":\"1.7\",\"parentNo\":\"1\",\"href\":\"/并发/共享锁独占锁#锁的升降级\",\"child\":[{\"type\":\"heading\",\"index\":16,\"level\":3,\"text\":\"降级的过程\",\"listNo\":\"1.7.1\",\"parentNo\":\"1.7\",\"href\":\"/并发/共享锁独占锁#降级的过程\",\"child\":[]},{\"type\":\"heading\",\"index\":17,\"level\":3,\"text\":\"为什么需要锁的降级\",\"listNo\":\"1.7.2\",\"parentNo\":\"1.7\",\"href\":\"/并发/共享锁独占锁#为什么需要锁的降级\",\"child\":[]},{\"type\":\"heading\",\"index\":18,\"level\":3,\"text\":\"为什么不支持锁的升级？\",\"listNo\":\"1.7.3\",\"parentNo\":\"1.7\",\"href\":\"/并发/共享锁独占锁#为什么不支持锁的升级？\",\"child\":[]},{\"type\":\"heading\",\"index\":19,\"level\":3,\"text\":\"总结\",\"listNo\":\"1.7.4\",\"parentNo\":\"1.7\",\"href\":\"/并发/共享锁独占锁#总结\",\"child\":[]}]}]},{\"type\":\"heading\",\"index\":14,\"level\":2,\"text\":\"公平锁/非公平锁\",\"listNo\":\"1.11\",\"parentNo\":\"1\",\"href\":\"/并发/公平锁非公平锁\",\"child\":[{\"type\":\"heading\",\"index\":1,\"level\":2,\"text\":\"特点\",\"listNo\":\"1.1\",\"parentNo\":\"1\",\"href\":\"/并发/公平锁非公平锁#特点\",\"child\":[]},{\"type\":\"heading\",\"index\":2,\"level\":2,\"text\":\"案例\",\"listNo\":\"1.2\",\"parentNo\":\"1\",\"href\":\"/并发/公平锁非公平锁#案例\",\"child\":[]},{\"type\":\"heading\",\"index\":3,\"level\":2,\"text\":\"源码\",\"listNo\":\"1.3\",\"parentNo\":\"1\",\"href\":\"/并发/公平锁非公平锁#源码\",\"child\":[]}]},{\"type\":\"heading\",\"index\":15,\"level\":2,\"text\":\"乐观锁/悲观锁\",\"listNo\":\"1.12\",\"parentNo\":\"1\",\"href\":\"/并发/乐观锁和悲观锁\",\"child\":[{\"type\":\"heading\",\"index\":1,\"level\":2,\"text\":\"悲观锁\",\"listNo\":\"1.1\",\"parentNo\":\"1\",\"href\":\"/并发/乐观锁和悲观锁#悲观锁\",\"child\":[]},{\"type\":\"heading\",\"index\":2,\"level\":2,\"text\":\"乐观锁\",\"listNo\":\"1.2\",\"parentNo\":\"1\",\"href\":\"/并发/乐观锁和悲观锁#乐观锁\",\"child\":[]},{\"type\":\"heading\",\"index\":3,\"level\":2,\"text\":\"典型案例\",\"listNo\":\"1.3\",\"parentNo\":\"1\",\"href\":\"/并发/乐观锁和悲观锁#典型案例\",\"child\":[{\"type\":\"heading\",\"index\":7,\"level\":3,\"text\":\"“汝之蜜糖,彼之砒霜”\",\"listNo\":\"1.3.4\",\"parentNo\":\"1.3\",\"href\":\"/并发/乐观锁和悲观锁#“汝之蜜糖,彼之砒霜”\",\"child\":[]}]},{\"type\":\"heading\",\"index\":8,\"level\":2,\"text\":\"两种锁各自的使用场景\",\"listNo\":\"1.4\",\"parentNo\":\"1\",\"href\":\"/并发/乐观锁和悲观锁#两种锁各自的使用场景\",\"child\":[]}]},{\"type\":\"heading\",\"index\":16,\"level\":2,\"text\":\"自旋锁/非自旋锁\",\"listNo\":\"1.13\",\"parentNo\":\"1\",\"href\":\"/并发/自旋锁非自旋锁\",\"child\":[{\"type\":\"heading\",\"index\":1,\"level\":2,\"text\":\"对比自旋和非自旋获取锁的流程\",\"listNo\":\"1.1\",\"parentNo\":\"1\",\"href\":\"/并发/自旋锁非自旋锁#对比自旋和非自旋获取锁的流程\",\"child\":[]},{\"type\":\"heading\",\"index\":2,\"level\":2,\"text\":\"自旋锁的好处\",\"listNo\":\"1.2\",\"parentNo\":\"1\",\"href\":\"/并发/自旋锁非自旋锁#自旋锁的好处\",\"child\":[]},{\"type\":\"heading\",\"index\":3,\"level\":2,\"text\":\"自旋锁的缺点\",\"listNo\":\"1.3\",\"parentNo\":\"1\",\"href\":\"/并发/自旋锁非自旋锁#自旋锁的缺点\",\"child\":[]},{\"type\":\"heading\",\"index\":4,\"level\":2,\"text\":\"适用场景\",\"listNo\":\"1.4\",\"parentNo\":\"1\",\"href\":\"/并发/自旋锁非自旋锁#适用场景\",\"child\":[]}]},{\"type\":\"heading\",\"index\":17,\"level\":2,\"text\":\"不可中断锁/可中断锁\",\"listNo\":\"1.14\",\"parentNo\":\"1\",\"href\":\"/并发/锁的种类和特点#不可中断锁/可中断锁\",\"child\":[]}]},{\"index\":21,\"type\":\"list_item\",\"level\":4,\"text\":\"synchronized 和 Lock的对比\",\"listNo\":\"1.2.2.2\",\"parentNo\":\"1.2.2\",\"href\":\"/并发/synchronized和Lock的对比\",\"child\":[{\"type\":\"heading\",\"index\":1,\"level\":2,\"text\":\"相同点\",\"listNo\":\"1.1\",\"parentNo\":\"1\",\"href\":\"/并发/synchronized和Lock的对比#相同点\",\"child\":[{\"type\":\"heading\",\"index\":2,\"level\":3,\"text\":\"用来保护资源安全\",\"listNo\":\"1.1.1\",\"parentNo\":\"1.1\",\"href\":\"/并发/synchronized和Lock的对比#用来保护资源安全\",\"child\":[]},{\"type\":\"heading\",\"index\":3,\"level\":3,\"text\":\"都可以保证可见性\",\"listNo\":\"1.1.2\",\"parentNo\":\"1.1\",\"href\":\"/并发/synchronized和Lock的对比#都可以保证可见性\",\"child\":[]},{\"type\":\"heading\",\"index\":4,\"level\":3,\"text\":\"都可重入\",\"listNo\":\"1.1.3\",\"parentNo\":\"1.1\",\"href\":\"/并发/synchronized和Lock的对比#都可重入\",\"child\":[]}]},{\"type\":\"heading\",\"index\":5,\"level\":2,\"text\":\"不同点\",\"listNo\":\"1.2\",\"parentNo\":\"1\",\"href\":\"/并发/synchronized和Lock的对比#不同点\",\"child\":[{\"type\":\"heading\",\"index\":6,\"level\":3,\"text\":\"用法不同\",\"listNo\":\"1.2.1\",\"parentNo\":\"1.2\",\"href\":\"/并发/synchronized和Lock的对比#用法不同\",\"child\":[]},{\"type\":\"heading\",\"index\":9,\"level\":3,\"text\":\"加解锁顺序不同\",\"listNo\":\"1.2.2\",\"parentNo\":\"1.2\",\"href\":\"/并发/synchronized和Lock的对比#加解锁顺序不同\",\"child\":[]},{\"type\":\"heading\",\"index\":12,\"level\":3,\"text\":\"synchronized锁不够灵活\",\"listNo\":\"1.2.3\",\"parentNo\":\"1.2\",\"href\":\"/并发/synchronized和Lock的对比#synchronized锁不够灵活\",\"child\":[]},{\"type\":\"heading\",\"index\":13,\"level\":3,\"text\":\"synchronized锁同时只能被一个线程拥有，Lock没有这个限制\",\"listNo\":\"1.2.4\",\"parentNo\":\"1.2\",\"href\":\"/并发/synchronized和Lock的对比#synchronized锁同时只能被一个线程拥有，Lock没有这个限制\",\"child\":[]},{\"type\":\"heading\",\"index\":14,\"level\":3,\"text\":\"是否可以设置公平锁\",\"listNo\":\"1.2.5\",\"parentNo\":\"1.2\",\"href\":\"/并发/synchronized和Lock的对比#是否可以设置公平锁\",\"child\":[]},{\"type\":\"heading\",\"index\":15,\"level\":3,\"text\":\"性能区别\",\"listNo\":\"1.2.6\",\"parentNo\":\"1.2\",\"href\":\"/并发/synchronized和Lock的对比#性能区别\",\"child\":[]}]},{\"type\":\"heading\",\"index\":16,\"level\":2,\"text\":\"如何选择\",\"listNo\":\"1.3\",\"parentNo\":\"1\",\"href\":\"/并发/lock的常用方法\",\"child\":[]}]},{\"index\":22,\"type\":\"list_item\",\"level\":4,\"text\":\"JVM锁优化\",\"listNo\":\"1.2.2.3\",\"parentNo\":\"1.2.2\",\"href\":\"/并发/JVM锁优化\",\"child\":[{\"type\":\"heading\",\"index\":1,\"level\":2,\"text\":\"锁消除\",\"listNo\":\"1.1\",\"parentNo\":\"1\",\"href\":\"/并发/JVM锁优化#锁消除\",\"child\":[]},{\"type\":\"heading\",\"index\":2,\"level\":2,\"text\":\"锁粗化\",\"listNo\":\"1.2\",\"parentNo\":\"1\",\"href\":\"/并发/JVM锁优化#锁粗化\",\"child\":[]},{\"type\":\"heading\",\"index\":3,\"level\":2,\"text\":\"自适应锁自旋\",\"listNo\":\"1.3\",\"parentNo\":\"1\",\"href\":\"/并发/JVM锁优化#自适应锁自旋\",\"child\":[]},{\"type\":\"heading\",\"index\":4,\"level\":2,\"text\":\"偏向锁/轻量级锁/重量级锁\",\"listNo\":\"1.4\",\"parentNo\":\"1\",\"href\":\"/并发/JVM锁优化#偏向锁/轻量级锁/重量级锁\",\"child\":[]},{\"type\":\"heading\",\"index\":8,\"level\":2,\"text\":\"synchronized加锁流程\",\"listNo\":\"1.5\",\"parentNo\":\"1\",\"href\":\"/并发/JVM锁优化# synchronized加锁流程\",\"child\":[]}]}]},{\"type\":\"heading\",\"index\":23,\"level\":3,\"text\":\"并发容器\",\"listNo\":\"1.2.3\",\"parentNo\":\"1.2\",\"href\":\"/并发/README#并发容器\",\"child\":[{\"index\":24,\"type\":\"list_item\",\"level\":4,\"text\":\"线程不安全的HashMap\",\"listNo\":\"1.2.3.1\",\"parentNo\":\"1.2.3\",\"href\":\"/并发/HashMap\",\"child\":[{\"type\":\"heading\",\"index\":1,\"level\":2,\"text\":\"HashMap实现原理\",\"listNo\":\"1.1\",\"parentNo\":\"1\",\"href\":\"/并发/HashMap#HashMap实现原理\",\"child\":[]},{\"type\":\"heading\",\"index\":4,\"level\":2,\"text\":\"功能实现\",\"listNo\":\"1.2\",\"parentNo\":\"1\",\"href\":\"/并发/HashMap#功能实现\",\"child\":[{\"type\":\"heading\",\"index\":8,\"level\":3,\"text\":\"为什么hashmap的在链表元素数量超过8时改为红黑树?\",\"listNo\":\"1.2.4\",\"parentNo\":\"1.2\",\"href\":\"/并发/HashMap#为什么hashmap的在链表元素数量超过8时改为红黑树?\",\"child\":[]}]},{\"type\":\"heading\",\"index\":12,\"level\":2,\"text\":\"线程安全性\",\"listNo\":\"1.3\",\"parentNo\":\"1\",\"href\":\"/并发/HashMap#线程安全性\",\"child\":[]}]},{\"index\":25,\"type\":\"list_item\",\"level\":4,\"text\":\"线程安全的ConcurrentHashMap\",\"listNo\":\"1.2.3.2\",\"parentNo\":\"1.2.3\",\"href\":\"/并发/ConcurrentHashMap详解\",\"child\":[{\"type\":\"heading\",\"index\":1,\"level\":2,\"text\":\"ConcurrentHashMap_JDK7\",\"listNo\":\"1.1\",\"parentNo\":\"1\",\"href\":\"/并发/ConcurrentHashMap详解#ConcurrentHashMap_JDK7\",\"child\":[{\"type\":\"heading\",\"index\":2,\"level\":3,\"text\":\"数据结构\",\"listNo\":\"1.1.1\",\"parentNo\":\"1.1\",\"href\":\"/并发/ConcurrentHashMap详解#数据结构\",\"child\":[]},{\"type\":\"heading\",\"index\":3,\"level\":3,\"text\":\"初始化\",\"listNo\":\"1.1.2\",\"parentNo\":\"1.1\",\"href\":\"/并发/ConcurrentHashMap详解#初始化\",\"child\":[]},{\"type\":\"heading\",\"index\":4,\"level\":3,\"text\":\"初始化\",\"listNo\":\"1.1.3\",\"parentNo\":\"1.1\",\"href\":\"/并发/ConcurrentHashMap详解#初始化\",\"child\":[]},{\"type\":\"heading\",\"index\":9,\"level\":3,\"text\":\"put过程分析\",\"listNo\":\"1.1.4\",\"parentNo\":\"1.1\",\"href\":\"/并发/ConcurrentHashMap详解#put过程分析\",\"child\":[]},{\"type\":\"heading\",\"index\":10,\"level\":3,\"text\":\"初始化槽: ensureSegment\",\"listNo\":\"1.1.5\",\"parentNo\":\"1.1\",\"href\":\"/并发/ConcurrentHashMap详解#初始化槽: ensureSegment\",\"child\":[]},{\"type\":\"heading\",\"index\":13,\"level\":3,\"text\":\"get 过程分析\",\"listNo\":\"1.1.6\",\"parentNo\":\"1.1\",\"href\":\"/并发/ConcurrentHashMap详解#get 过程分析\",\"child\":[]},{\"type\":\"heading\",\"index\":17,\"level\":3,\"text\":\"并发问题分析\",\"listNo\":\"1.1.7\",\"parentNo\":\"1.1\",\"href\":\"/并发/ConcurrentHashMap详解#并发问题分析\",\"child\":[]}]},{\"type\":\"heading\",\"index\":27,\"level\":2,\"text\":\"ConcurrentHashMap_JDK8\",\"listNo\":\"1.2\",\"parentNo\":\"1\",\"href\":\"/并发/ConcurrentHashMap详解#ConcurrentHashMap_JDK8\",\"child\":[{\"type\":\"heading\",\"index\":31,\"level\":3,\"text\":\"put 方法源码分析\",\"listNo\":\"1.2.4\",\"parentNo\":\"1.2\",\"href\":\"/并发/ConcurrentHashMap详解# put 方法源码分析\",\"child\":[]},{\"type\":\"heading\",\"index\":32,\"level\":3,\"text\":\"get 方法源码分析\",\"listNo\":\"1.2.5\",\"parentNo\":\"1.2\",\"href\":\"/并发/ConcurrentHashMap详解#get 方法源码分析\",\"child\":[]}]},{\"type\":\"heading\",\"index\":38,\"level\":2,\"text\":\"对比Java7 和Java8 的异同和优缺点\",\"listNo\":\"1.3\",\"parentNo\":\"1\",\"href\":\"/并发/ConcurrentHashMap详解#对比Java7 和Java8 的异同和优缺点\",\"child\":[{\"type\":\"heading\",\"index\":39,\"level\":3,\"text\":\"并发度\",\"listNo\":\"1.3.1\",\"parentNo\":\"1.3\",\"href\":\"/并发/ConcurrentHashMap详解#并发度\",\"child\":[]},{\"type\":\"heading\",\"index\":40,\"level\":3,\"text\":\"保证并发安全的原理\",\"listNo\":\"1.3.2\",\"parentNo\":\"1.3\",\"href\":\"/并发/ConcurrentHashMap详解#保证并发安全的原理\",\"child\":[]},{\"type\":\"heading\",\"index\":42,\"level\":3,\"text\":\"遇到 Hash 碰撞\",\"listNo\":\"1.3.3\",\"parentNo\":\"1.3\",\"href\":\"/并发/ConcurrentHashMap详解#遇到 Hash 碰撞\",\"child\":[]},{\"type\":\"heading\",\"index\":43,\"level\":3,\"text\":\"查询时间复杂度\",\"listNo\":\"1.3.4\",\"parentNo\":\"1.3\",\"href\":\"/并发/ConcurrentHashMap详解#查询时间复杂度\",\"child\":[]}]}]},{\"index\":26,\"type\":\"list_item\",\"level\":4,\"text\":\"线程安全ArrayList集合-CopyOnWriteArrayList\",\"listNo\":\"1.2.3.3\",\"parentNo\":\"1.2.3\",\"href\":\"/并发/CopyOnWriteArrayList\",\"child\":[{\"type\":\"heading\",\"index\":1,\"level\":2,\"text\":\"特点\",\"listNo\":\"1.1\",\"parentNo\":\"1\",\"href\":\"/并发/CopyOnWriteArrayList#特点\",\"child\":[]},{\"type\":\"heading\",\"index\":2,\"level\":2,\"text\":\"复制修改\",\"listNo\":\"1.2\",\"parentNo\":\"1\",\"href\":\"/并发/CopyOnWriteArrayList#复制修改\",\"child\":[{\"type\":\"heading\",\"index\":3,\"level\":3,\"text\":\"迭代期间允许修改集合内容\",\"listNo\":\"1.2.1\",\"parentNo\":\"1.2\",\"href\":\"/并发/CopyOnWriteArrayList#迭代期间允许修改集合内容\",\"child\":[]}]},{\"type\":\"heading\",\"index\":4,\"level\":2,\"text\":\"缺点\",\"listNo\":\"1.3\",\"parentNo\":\"1\",\"href\":\"/并发/CopyOnWriteArrayList#缺点\",\"child\":[{\"type\":\"heading\",\"index\":5,\"level\":3,\"text\":\"内存占用大\",\"listNo\":\"1.3.1\",\"parentNo\":\"1.3\",\"href\":\"/并发/CopyOnWriteArrayList#内存占用大\",\"child\":[]},{\"type\":\"heading\",\"index\":6,\"level\":3,\"text\":\"元素较多或者复杂的情况下，复制的开销大\",\"listNo\":\"1.3.2\",\"parentNo\":\"1.3\",\"href\":\"/并发/CopyOnWriteArrayList#元素较多或者复杂的情况下，复制的开销大\",\"child\":[]},{\"type\":\"heading\",\"index\":7,\"level\":3,\"text\":\"数据一致性无法保证\",\"listNo\":\"1.3.3\",\"parentNo\":\"1.3\",\"href\":\"/并发/CopyOnWriteArrayList#数据一致性无法保证\",\"child\":[]},{\"type\":\"heading\",\"index\":8,\"level\":3,\"text\":\"只适合读多写少的场景\",\"listNo\":\"1.3.4\",\"parentNo\":\"1.3\",\"href\":\"/并发/CopyOnWriteArrayList#只适合读多写少的场景\",\"child\":[]}]},{\"type\":\"heading\",\"index\":9,\"level\":2,\"text\":\"源码分析\",\"listNo\":\"1.4\",\"parentNo\":\"1\",\"href\":\"/并发/CopyOnWriteArrayList#源码分析\",\"child\":[{\"type\":\"heading\",\"index\":10,\"level\":3,\"text\":\"数据结构\",\"listNo\":\"1.4.1\",\"parentNo\":\"1.4\",\"href\":\"/并发/CopyOnWriteArrayList#数据结构\",\"child\":[]},{\"type\":\"heading\",\"index\":11,\"level\":3,\"text\":\"add方法\",\"listNo\":\"1.4.2\",\"parentNo\":\"1.4\",\"href\":\"/并发/CopyOnWriteArrayList#add方法\",\"child\":[]},{\"type\":\"heading\",\"index\":12,\"level\":3,\"text\":\"get操作\",\"listNo\":\"1.4.3\",\"parentNo\":\"1.4\",\"href\":\"/并发/CopyOnWriteArrayList#get操作\",\"child\":[]},{\"type\":\"heading\",\"index\":13,\"level\":3,\"text\":\"迭代器COWIterator类\",\"listNo\":\"1.4.4\",\"parentNo\":\"1.4\",\"href\":\"/并发/CopyOnWriteArrayList#迭代器COWIterator类\",\"child\":[]}]}]}]},{\"type\":\"heading\",\"index\":27,\"level\":3,\"text\":\"阻塞队列\",\"listNo\":\"1.2.4\",\"parentNo\":\"1.2\",\"href\":\"/并发/README#阻塞队列\",\"child\":[{\"index\":28,\"type\":\"list_item\",\"level\":4,\"text\":\"什么是阻塞队列\",\"listNo\":\"1.2.4.1\",\"parentNo\":\"1.2.4\",\"href\":\"/并发/什么是阻塞队列\",\"child\":[{\"type\":\"heading\",\"index\":1,\"level\":2,\"text\":\"阻塞队列的作用\",\"listNo\":\"1.1\",\"parentNo\":\"1\",\"href\":\"/并发/什么是阻塞队列#阻塞队列的作用\",\"child\":[]},{\"type\":\"heading\",\"index\":2,\"level\":2,\"text\":\"主要并发队列关系图\",\"listNo\":\"1.2\",\"parentNo\":\"1\",\"href\":\"/并发/什么是阻塞队列#主要并发队列关系图\",\"child\":[]},{\"type\":\"heading\",\"index\":9,\"level\":2,\"text\":\"阻塞队列的特点\",\"listNo\":\"1.3\",\"parentNo\":\"1\",\"href\":\"/并发/什么是阻塞队列#阻塞队列的特点\",\"child\":[{\"type\":\"heading\",\"index\":12,\"level\":3,\"text\":\"是否有界（容量有多大）\",\"listNo\":\"1.3.3\",\"parentNo\":\"1.3\",\"href\":\"/并发/什么是阻塞队列#是否有界（容量有多大）\",\"child\":[]}]}]},{\"index\":29,\"type\":\"list_item\",\"level\":4,\"text\":\"阻塞队列的常用方法\",\"listNo\":\"1.2.4.2\",\"parentNo\":\"1.2.4\",\"href\":\"/并发/阻塞队列的常用方法\",\"child\":[{\"type\":\"heading\",\"index\":4,\"level\":2,\"text\":\"第一组：add、remove、element\",\"listNo\":\"1.4\",\"parentNo\":\"1\",\"href\":\"/并发/阻塞队列的常用方法#第一组：add、remove、element\",\"child\":[{\"type\":\"heading\",\"index\":5,\"level\":3,\"text\":\"add 方法\",\"listNo\":\"1.4.1\",\"parentNo\":\"1.4\",\"href\":\"/并发/阻塞队列的常用方法#add 方法\",\"child\":[]},{\"type\":\"heading\",\"index\":6,\"level\":3,\"text\":\"remove 方法\",\"listNo\":\"1.4.2\",\"parentNo\":\"1.4\",\"href\":\"/并发/阻塞队列的常用方法#remove 方法\",\"child\":[]},{\"type\":\"heading\",\"index\":7,\"level\":3,\"text\":\"element 方法\",\"listNo\":\"1.4.3\",\"parentNo\":\"1.4\",\"href\":\"/并发/阻塞队列的常用方法#element 方法\",\"child\":[]}]},{\"type\":\"heading\",\"index\":8,\"level\":2,\"text\":\"第二组：offer、poll、peek\",\"listNo\":\"1.5\",\"parentNo\":\"1\",\"href\":\"/并发/阻塞队列的常用方法#第二组：offer、poll、peek\",\"child\":[{\"type\":\"heading\",\"index\":9,\"level\":3,\"text\":\"offer 方法\",\"listNo\":\"1.5.1\",\"parentNo\":\"1.5\",\"href\":\"/并发/阻塞队列的常用方法#offer 方法\",\"child\":[]},{\"type\":\"heading\",\"index\":10,\"level\":3,\"text\":\"poll 方法\",\"listNo\":\"1.5.2\",\"parentNo\":\"1.5\",\"href\":\"/并发/阻塞队列的常用方法#poll 方法\",\"child\":[]},{\"type\":\"heading\",\"index\":11,\"level\":3,\"text\":\"peek 方法\",\"listNo\":\"1.5.3\",\"parentNo\":\"1.5\",\"href\":\"/并发/阻塞队列的常用方法#peek 方法\",\"child\":[]},{\"type\":\"heading\",\"index\":12,\"level\":3,\"text\":\"带超时时间的 offer 和 poll\",\"listNo\":\"1.5.4\",\"parentNo\":\"1.5\",\"href\":\"/并发/阻塞队列的常用方法#带超时时间的 offer 和 poll\",\"child\":[]},{\"type\":\"heading\",\"index\":13,\"level\":3,\"text\":\"第三组：put、take\",\"listNo\":\"1.5.5\",\"parentNo\":\"1.5\",\"href\":\"/并发/阻塞队列的常用方法#第三组：put、take\",\"child\":[]},{\"type\":\"heading\",\"index\":14,\"level\":3,\"text\":\"put 方法\",\"listNo\":\"1.5.6\",\"parentNo\":\"1.5\",\"href\":\"/并发/阻塞队列的常用方法#put 方法\",\"child\":[]},{\"type\":\"heading\",\"index\":15,\"level\":3,\"text\":\"take 方法\",\"listNo\":\"1.5.7\",\"parentNo\":\"1.5\",\"href\":\"/并发/阻塞队列的常用方法#take 方法\",\"child\":[]}]},{\"type\":\"heading\",\"index\":16,\"level\":2,\"text\":\"总结\",\"listNo\":\"1.6\",\"parentNo\":\"1\",\"href\":\"/并发/阻塞队列的常用方法#总结\",\"child\":[]}]},{\"index\":30,\"type\":\"list_item\",\"level\":4,\"text\":\"常见的阻塞队列\",\"listNo\":\"1.2.4.3\",\"parentNo\":\"1.2.4\",\"href\":\"/并发/常见的阻塞队列\",\"child\":[{\"type\":\"heading\",\"index\":1,\"level\":2,\"text\":\"ArrayBlockingQueue\",\"listNo\":\"1.1\",\"parentNo\":\"1\",\"href\":\"/并发/常见的阻塞队列#ArrayBlockingQueue\",\"child\":[]},{\"type\":\"heading\",\"index\":2,\"level\":2,\"text\":\"LinkedBlockingQueue\",\"listNo\":\"1.2\",\"parentNo\":\"1\",\"href\":\"/并发/常见的阻塞队列#LinkedBlockingQueue\",\"child\":[]},{\"type\":\"heading\",\"index\":3,\"level\":2,\"text\":\"SynchronousQueue\",\"listNo\":\"1.3\",\"parentNo\":\"1\",\"href\":\"/并发/常见的阻塞队列#SynchronousQueue\",\"child\":[]},{\"type\":\"heading\",\"index\":4,\"level\":2,\"text\":\"PriorityBlockingQueue\",\"listNo\":\"1.4\",\"parentNo\":\"1\",\"href\":\"/并发/常见的阻塞队列#PriorityBlockingQueue\",\"child\":[]},{\"type\":\"heading\",\"index\":5,\"level\":2,\"text\":\"DelayQueue\",\"listNo\":\"1.5\",\"parentNo\":\"1\",\"href\":\"/并发/常见的阻塞队列#DelayQueue\",\"child\":[]},{\"type\":\"heading\",\"index\":6,\"level\":2,\"text\":\"如何选择\",\"listNo\":\"1.6\",\"parentNo\":\"1\",\"href\":\"/并发/常见的阻塞队列#如何选择\",\"child\":[{\"type\":\"heading\",\"index\":7,\"level\":3,\"text\":\"线程池对于阻塞队列的选择\",\"listNo\":\"1.6.1\",\"parentNo\":\"1.6\",\"href\":\"/并发/常见的阻塞队列#线程池对于阻塞队列的选择\",\"child\":[]},{\"type\":\"heading\",\"index\":13,\"level\":3,\"text\":\"归纳\",\"listNo\":\"1.6.2\",\"parentNo\":\"1.6\",\"href\":\"/并发/常见的阻塞队列#归纳\",\"child\":[]}]}]}]},{\"type\":\"heading\",\"index\":31,\"level\":3,\"text\":\"原子类\",\"listNo\":\"1.2.5\",\"parentNo\":\"1.2\",\"href\":\"/并发/README#原子类\",\"child\":[{\"index\":32,\"type\":\"list_item\",\"level\":4,\"text\":\"原子类的作用概览\",\"listNo\":\"1.2.5.1\",\"parentNo\":\"1.2.5\",\"href\":\"/并发/原子类的作用概览\",\"child\":[{\"type\":\"heading\",\"index\":1,\"level\":2,\"text\":\"什么是原子类，有什么作用\",\"listNo\":\"1.1\",\"parentNo\":\"1\",\"href\":\"/并发/原子类的作用概览#什么是原子类，有什么作用\",\"child\":[]},{\"type\":\"heading\",\"index\":4,\"level\":2,\"text\":\"原子类概览\",\"listNo\":\"1.2\",\"parentNo\":\"1\",\"href\":\"/并发/原子类的作用概览#原子类概览\",\"child\":[{\"type\":\"heading\",\"index\":7,\"level\":3,\"text\":\"原子更新基本类型\",\"listNo\":\"1.2.3\",\"parentNo\":\"1.2\",\"href\":\"/并发/原子类的作用概览#原子更新基本类型\",\"child\":[]},{\"type\":\"heading\",\"index\":11,\"level\":3,\"text\":\"原子更新数组\",\"listNo\":\"1.2.4\",\"parentNo\":\"1.2\",\"href\":\"/并发/原子类的作用概览#原子更新数组\",\"child\":[]},{\"type\":\"heading\",\"index\":15,\"level\":3,\"text\":\"原子更新引用类型\",\"listNo\":\"1.2.5\",\"parentNo\":\"1.2\",\"href\":\"/并发/原子类的作用概览#原子更新引用类型\",\"child\":[]},{\"type\":\"heading\",\"index\":19,\"level\":3,\"text\":\"原子更新字段\",\"listNo\":\"1.2.6\",\"parentNo\":\"1.2\",\"href\":\"/并发/原子类的作用概览#原子更新字段\",\"child\":[]},{\"type\":\"heading\",\"index\":31,\"level\":3,\"text\":\"Adder 加法器和Accumulator积累器\",\"listNo\":\"1.2.7\",\"parentNo\":\"1.2\",\"href\":\"/并发/原子类的作用概览#Adder 加法器和Accumulator积累器\",\"child\":[{\"type\":\"heading\",\"index\":32,\"level\":4,\"text\":\"Adder介绍\",\"listNo\":\"1.2.7.1\",\"parentNo\":\"1.2.7\",\"href\":\"/并发/原子类的作用概览#Adder介绍\",\"child\":[]},{\"type\":\"heading\",\"index\":33,\"level\":4,\"text\":\"Accumulator介绍\",\"listNo\":\"1.2.7.2\",\"parentNo\":\"1.2.7\",\"href\":\"/并发/原子类的作用概览#Accumulator介绍\",\"child\":[]},{\"type\":\"heading\",\"index\":38,\"level\":4,\"text\":\"拓展功能\",\"listNo\":\"1.2.7.3\",\"parentNo\":\"1.2.7\",\"href\":\"/并发/原子类的作用概览#拓展功能\",\"child\":[]},{\"type\":\"heading\",\"index\":40,\"level\":4,\"text\":\"适用场景\",\"listNo\":\"1.2.7.4\",\"parentNo\":\"1.2.7\",\"href\":\"/并发/原子类的作用概览#适用场景\",\"child\":[]}]}]}]},{\"index\":33,\"type\":\"list_item\",\"level\":4,\"text\":\"原子类的性能分析\",\"listNo\":\"1.2.5.2\",\"parentNo\":\"1.2.5\",\"href\":\"/并发/原子类的性能分析\",\"child\":[{\"type\":\"heading\",\"index\":1,\"level\":2,\"text\":\"AtomicLong的问题\",\"listNo\":\"1.1\",\"parentNo\":\"1\",\"href\":\"/并发/原子类的性能分析#AtomicLong的问题\",\"child\":[]},{\"type\":\"heading\",\"index\":2,\"level\":2,\"text\":\"升级版LongAdder\",\"listNo\":\"1.2\",\"parentNo\":\"1\",\"href\":\"/并发/原子类的性能分析#升级版LongAdder\",\"child\":[]},{\"type\":\"heading\",\"index\":3,\"level\":2,\"text\":\"如何选择\",\"listNo\":\"1.3\",\"parentNo\":\"1\",\"href\":\"/并发/原子类的性能分析#如何选择\",\"child\":[{\"type\":\"heading\",\"index\":4,\"level\":3,\"text\":\"AtomicLong 可否被 LongAdder 替代？\",\"listNo\":\"1.3.1\",\"parentNo\":\"1.3\",\"href\":\"/并发/原子类的性能分析#AtomicLong 可否被 LongAdder 替代？\",\"child\":[]}]},{\"type\":\"heading\",\"index\":5,\"level\":2,\"text\":\"结论\",\"listNo\":\"1.4\",\"parentNo\":\"1\",\"href\":\"/并发/原子类的性能分析#结论\",\"child\":[]}]}]},{\"type\":\"heading\",\"index\":34,\"level\":3,\"text\":\"ThreadLocal\",\"listNo\":\"1.2.6\",\"parentNo\":\"1.2\",\"href\":\"/并发/README#ThreadLocal\",\"child\":[{\"index\":35,\"type\":\"list_item\",\"level\":4,\"text\":\"使用场景\",\"listNo\":\"1.2.6.1\",\"parentNo\":\"1.2.6\",\"href\":\"/并发/ThreadLocal使用场景\",\"child\":[{\"type\":\"heading\",\"index\":3,\"level\":2,\"text\":\"保存线程不安全的工具类\",\"listNo\":\"1.3\",\"parentNo\":\"1\",\"href\":\"/并发/ThreadLocal使用场景#保存线程不安全的工具类\",\"child\":[]},{\"type\":\"heading\",\"index\":4,\"level\":2,\"text\":\"传递全局变量\",\"listNo\":\"1.4\",\"parentNo\":\"1\",\"href\":\"/并发/ThreadLocal使用场景#传递全局变量\",\"child\":[]},{\"type\":\"heading\",\"index\":7,\"level\":2,\"text\":\"面试题: ThreadLocal是用来解决共享资源的多线程访问吗?\",\"listNo\":\"1.5\",\"parentNo\":\"1\",\"href\":\"/并发/ThreadLocal使用场景#面试题: ThreadLocal是用来解决共享资源的多线程访问吗?\",\"child\":[{\"type\":\"heading\",\"index\":8,\"level\":3,\"text\":\"ThreadLocal 和 synchronized 是什么关系\",\"listNo\":\"1.5.1\",\"parentNo\":\"1.5\",\"href\":\"/并发/ThreadLocal使用场景#ThreadLocal 和 synchronized 是什么关系\",\"child\":[]}]}]},{\"index\":36,\"type\":\"list_item\",\"level\":4,\"text\":\"内存泄漏\",\"listNo\":\"1.2.6.2\",\"parentNo\":\"1.2.6\",\"href\":\"/并发/ThreadLocal内存泄漏\",\"child\":[{\"type\":\"heading\",\"index\":1,\"level\":2,\"text\":\"ThreadLocal的实现原理\",\"listNo\":\"1.1\",\"parentNo\":\"1\",\"href\":\"/并发/ThreadLocal内存泄漏#ThreadLocal的实现原理\",\"child\":[]},{\"type\":\"heading\",\"index\":2,\"level\":2,\"text\":\"内存泄漏的案例\",\"listNo\":\"1.2\",\"parentNo\":\"1\",\"href\":\"/并发/ThreadLocal内存泄漏#内存泄漏的案例\",\"child\":[]}]}]},{\"type\":\"heading\",\"index\":37,\"level\":3,\"text\":\"Future\",\"listNo\":\"1.2.7\",\"parentNo\":\"1.2\",\"href\":\"/并发/README#Future\",\"child\":[{\"index\":38,\"type\":\"list_item\",\"level\":4,\"text\":\"主要功能\",\"listNo\":\"1.2.7.1\",\"parentNo\":\"1.2.7\",\"href\":\"/并发/Future主要功能\",\"child\":[{\"type\":\"heading\",\"index\":1,\"level\":2,\"text\":\"Future接口\",\"listNo\":\"1.1\",\"parentNo\":\"1\",\"href\":\"/并发/Future主要功能#Future接口\",\"child\":[{\"type\":\"heading\",\"index\":2,\"level\":3,\"text\":\"cancel方法: 取消任务执行\",\"listNo\":\"1.1.1\",\"parentNo\":\"1.1\",\"href\":\"/并发/Future主要功能#cancel方法: 取消任务执行\",\"child\":[]},{\"type\":\"heading\",\"index\":8,\"level\":3,\"text\":\"isCancelled() 方法:判断是否被取消\",\"listNo\":\"1.1.2\",\"parentNo\":\"1.1\",\"href\":\"/并发/Future主要功能#isCancelled() 方法:判断是否被取消\",\"child\":[]},{\"type\":\"heading\",\"index\":9,\"level\":3,\"text\":\"isDown():判断是否执行完毕\",\"listNo\":\"1.1.3\",\"parentNo\":\"1.1\",\"href\":\"/并发/Future主要功能#isDown():判断是否执行完毕\",\"child\":[]},{\"type\":\"heading\",\"index\":14,\"level\":3,\"text\":\"get(): 获取结果\",\"listNo\":\"1.1.4\",\"parentNo\":\"1.1\",\"href\":\"/并发/Future主要功能#get(): 获取结果\",\"child\":[]}]},{\"type\":\"heading\",\"index\":20,\"level\":2,\"text\":\"基础实现\",\"listNo\":\"1.2\",\"parentNo\":\"1\",\"href\":\"/并发/Future主要功能#基础实现\",\"child\":[{\"type\":\"heading\",\"index\":21,\"level\":3,\"text\":\"FutureTask示例\",\"listNo\":\"1.2.1\",\"parentNo\":\"1.2\",\"href\":\"/并发/Future主要功能#FutureTask示例\",\"child\":[]}]}]},{\"index\":39,\"type\":\"list_item\",\"level\":4,\"text\":\"FutureTask源码分析\",\"listNo\":\"1.2.7.2\",\"parentNo\":\"1.2.7\",\"href\":\"/并发/FutureTask源码分析\",\"child\":[{\"type\":\"heading\",\"index\":1,\"level\":2,\"text\":\"核心属性\",\"listNo\":\"1.1\",\"parentNo\":\"1\",\"href\":\"/并发/FutureTask源码分析#核心属性\",\"child\":[]},{\"type\":\"heading\",\"index\":9,\"level\":2,\"text\":\"构造函数\",\"listNo\":\"1.2\",\"parentNo\":\"1\",\"href\":\"/并发/FutureTask源码分析#构造函数\",\"child\":[]},{\"type\":\"heading\",\"index\":10,\"level\":2,\"text\":\"核心方法：Run()\",\"listNo\":\"1.3\",\"parentNo\":\"1\",\"href\":\"/并发/FutureTask源码分析#核心方法：Run()\",\"child\":[]},{\"type\":\"heading\",\"index\":15,\"level\":2,\"text\":\"核心方法:awaitDone(boolean timed,long nanos)\",\"listNo\":\"1.4\",\"parentNo\":\"1\",\"href\":\"/并发/FutureTask源码分析#核心方法:awaitDone(boolean timed,long nanos)\",\"child\":[]},{\"type\":\"heading\",\"index\":21,\"level\":2,\"text\":\"核心方法:Cancel()\",\"listNo\":\"1.5\",\"parentNo\":\"1\",\"href\":\"/并发/FutureTask源码分析#核心方法:Cancel()\",\"child\":[]}]}]},{\"type\":\"heading\",\"index\":40,\"level\":3,\"text\":\"线程协作\",\"listNo\":\"1.2.8\",\"parentNo\":\"1.2\",\"href\":\"/并发/README#线程协作\",\"child\":[]}]},{\"type\":\"heading\",\"index\":41,\"level\":2,\"text\":\"底层原理\",\"listNo\":\"1.3\",\"parentNo\":\"1\",\"href\":\"/并发/README#底层原理\",\"child\":[{\"type\":\"heading\",\"index\":42,\"level\":3,\"text\":\"Java内存模型\",\"listNo\":\"1.3.1\",\"parentNo\":\"1.3\",\"href\":\"/并发/README#Java内存模型\",\"child\":[]},{\"type\":\"heading\",\"index\":43,\"level\":3,\"text\":\"CAS原理\",\"listNo\":\"1.3.2\",\"parentNo\":\"1.3\",\"href\":\"/并发/README#CAS原理\",\"child\":[]},{\"type\":\"heading\",\"index\":44,\"level\":3,\"text\":\"死锁问题\",\"listNo\":\"1.3.3\",\"parentNo\":\"1.3\",\"href\":\"/并发/README#死锁问题\",\"child\":[]},{\"type\":\"heading\",\"index\":45,\"level\":3,\"text\":\"final关键字和不变性\",\"listNo\":\"1.3.4\",\"parentNo\":\"1.3\",\"href\":\"/并发/README#final关键字和不变性\",\"child\":[]},{\"type\":\"heading\",\"index\":46,\"level\":3,\"text\":\"AQS框架\",\"listNo\":\"1.3.5\",\"parentNo\":\"1.3\",\"href\":\"/并发/README#AQS框架\",\"child\":[]}]}]}]","name":"并发"}]