# 分布式锁使用场景

使用分布式锁的场景一般需要满足以下场景：

1. 系统是一个分布式系统，java的锁已经锁不住了。
2. 操作共享资源，比如库里唯一的用户数据。
3. 同步访问，即多个进程同时操作共享资源


消费积分在很多系统里都有，信用卡，电商网站，通过积分换礼品等，这里“消费积分”这个操作典型的需要使用锁的场景。

事件A： 以积分兑换礼品为例来讲，完整的积分消费过程简单分成3步：
1. A1：用户选中商品，发起兑换提交订单。
2. A2：系统读取用户剩余积分：判断用户当前积分是否充足。
3. A3：扣掉用户积分。

事件B： 系统给用户发放积分也简单分成3步：
1. B1：计算用户当天应得积分
2. B2：读取用户原有积分
3. B3：在原有积分上增加本次应得积分

那么问题来了，如果用户消费积分和用户累加积分同时发生（同时用户积分进行操作）会怎样？

假设：用户在消费积分的同时恰好离线任务在计算积分给用户发放积分（如根据用户当天的消费额），这两件事同时进行，下面的逻辑有点绕，耐心理解。

用户U有1000积分（记录用户积分的数据可以理解为共享资源），本次兑换要消耗掉999积分。

不加锁的情况：
事件A程序在执行到第2步读积分时，A:2操作读到的结果是1000分，判断剩余积分够本次兑换，紧接着要执行第3步A:3操作扣积分（1000 - 999 = 1），正常结果应该是用户还是1分。
但是这个时候事件B也在执行，本次要给用户U发放100积分，两个线程同时进行（同步访问）.

不加锁的情况，就会有下面这种可能，A:2 -> B:2 -> A:3 -> B:3 ,在A:3尚未完成前（扣积分，1000 - 999），用户U总积分被事件B的线程读取了，最后用户U的总积分变成了1100分，还白白兑换了一个999积分的礼物，这显然不符合预期结果。

有人说怎么可能这么巧同时操作用户积分，cpu那么快，只要用户足够多，并发量足够大，墨菲定律迟早生效，出现上述bug只是时间问题，还有可能被黑产行业卡住这个bug疯狂薅羊毛，这个时候作为开发人员要解决这个隐患就必须了解锁的使用。
（写代码是一项严谨的事儿！）

Java本身提供了两种内置的锁的实现，一种是由JVM实现的synchronized 和 JDK 提供的 Lock，以及很多原子操作类都是线程安全的，当你的应用是单机或者说单进程应用时，可以使用这两种锁来实现锁。

但是当下互联网公司的系统几乎都是分布式的，这个时候Java自带的 synchronized 或 Lock 已经无法满足分布式环境下锁的要求了，因为代码会部署在多台机器上，为了解决这个问题，分布式锁应运而生，分布式锁的特点是多进程，多个物理机器上无法共享内存，常见的解决办法是基于内存层的干涉，落地方案就是基于Redis的分布式锁 or ZooKeeper分布式锁。

[involution: 那常见的分布式锁有哪些解决方案，你有了解吗? -> Redis的分布式锁|Zookeeper分布式锁|基于数据库的乐观锁]

> 作者：是王炸呀
链接：https://juejin.cn/post/6844904137172189198
来源：掘金
