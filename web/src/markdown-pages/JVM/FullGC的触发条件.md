# FullGC的触发条件

1. 调用System.gc()

   + 只是建议虚拟机去触发GC，但是虚拟机不一定会真正执行。不建议使用这种方式去释放内存，应该交给虚拟机自行管理

2. 老年代空间不足

   1. 老年代空间不足的常见场景为大对象直接进入老年代、长期存活的对象进入老年代等。

      为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。


3. 空间分配担保失败


   1. 使用复制算法的MInorGC需要老年代的内存空间进行担保，如果老年代的空间不足则会进行一次Full GC

4. jdk7以及之前的永久代不足


   1. 在JDK1.7及之前,HotSpot虚拟机中的方法区是在永久代中实现的，永久代存储的是class的信息、常量、静态变量等数据。

      当系统中要加载的类、反射的类、或者调用的方法比较多时，就会占据永久代的空间，一旦满了就会导致Full GC

5. Concurrent Mode Failure

   这是CMS在执行垃圾收集的过程中，同时有新生代的大对象晋级到老年代，导致在收集的过程中有大量的浮动垃圾过多造成的暂时性内存空间不足，会报Concurrent Mode Failure的错，并执行一次Full GC