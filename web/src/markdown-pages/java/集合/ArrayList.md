# ArrayList

数组的复杂版本。提供动态增加和减少的api，实现了Collection和IList接口，还能够灵活的设置数组的大小。

## ArrayList有用过么？它是个什么东西？可以用来干嘛

ArrayList是利用数组为基础的可动态扩容的列表。可以利用它来装载数据，不过不能够装载基本类型，只能够装载他们的包装类。与它类似的有LinkedList，与LinkedList相比，ArrayList的查找和访问元素的速度较快，但是新增和删除元素的速度较慢。

**小结**：ArrayList底层是用数组实现的存储。允许放入null元素。

**特点**:查询效率高,新增删除效率低。线程不安全。使用评率高。



## 为什么线程不安全，我们还要用它

因为我们正常使用的场景中，都是用来查询，不会涉及太频繁的增删，如果涉及频繁的增删，可以使用LinkedList，如果你需要线程安全就使用Vector，这就是三者的区别了，实际开发过程中还是ArrayList使用最多的。

不存在一个集合工具是查询效率又高，增删效率也高的，还线程安全的，至于为啥大家看代码就知道了，因为数据结构的特性就是优劣共存的，想找个平衡点很难，牺牲了性能，那就安全，牺牲了安全那就快速。

## 您说它的底层实现是数组，但是数组的大小是定长的，如果我们不断的往里面添加数据的话，不会有问题吗？

Array有自动扩容机制，如果发现数组满了，会自动扩容到原本的数组的1.5倍。

**扩容时，会将老数组的元素复制一份到新的数组中，这个操作的代价很高。尽量避免**

![ArrayList](http://java-engineer.ztianzeng.com/uPic/ArrayList.png)

## 为什么扩容是1.5倍

因为1.5 可以充分利用移位操作，减少浮点数或者运算时间和运算次数。

## ArrayList增删很慢，具体原因是什么?

arrayList对于新增有两个api，一个是add(E e) 另一个是add(int index,E e);

add(E e) 是直接在数组的最后添加元素，add(int index,E e) 则是在指定位置添加元素。他们无一例外的都需要再数组长度=size的时候，需要进行扩容，但是add(int index,E e)中，如果index位于数组中间，则需要将index之后的位置统统向后移一位。

同样，删除元素的时候remove(int index)的时候，需要将index后的元素前移一位。

因此，在频繁的插入和删除中，会不断的对数组进行copy，造成效率低下。

## ArrayList删除在所有情况下都很慢么？

不是的。

ArrayList的删除效率，取决于删除的元素距离数组的末尾的距离，如果直接删除的是最后一位，则不涉及到copy数组。

## ArrayList适合做队列么?

不适合。

原因是，不论是头部插入尾部删除，还是尾部插入头部删除，都涉及到数组的拷贝，十分耗费性能。

## 那数组适合做队列吗?

数组是非常合适的。

[involution: 介绍一下ArrayBlockingQueue -> ArrayBlockingQueue]

比如ArrayBlockingQueue内部实现就是一个环形队列，它是一个定长队列，内部是用一个定长数组来实现的。

另外著名的Disruptor开源Library也是用环形数组来实现的超高性能队列，具体原理不做解释，比较复杂。

简单点说就是使用两个偏移量来标记数组的读位置和写位置，如果超过长度就折回到数组开头，前提是它们是定长数组。

## ArrayList的遍历和LinkedList遍历性能比较如何？

论遍历ArrayList要比LinkedList快得多，ArrayList遍历最大的优势在于内存的连续性，CPU的内部缓存结构会缓存连续的内存片段，可以大幅降低读取内存的性能开销。
